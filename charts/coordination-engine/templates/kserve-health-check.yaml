{{- if .Values.kserve.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "coordination-engine.fullname" . }}-kserve-health
  namespace: {{ .Release.Namespace }}
  annotations:
    argocd.argoproj.io/sync-wave: "2"
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
  labels:
    {{- include "coordination-engine.labels" . | nindent 4 }}
spec:
  backoffLimit: 10
  activeDeadlineSeconds: 600
  template:
    spec:
      serviceAccountName: {{ include "coordination-engine.serviceAccountName" . }}
      restartPolicy: OnFailure
      containers:
      - name: health-check
        image: curlimages/curl:8.5.0
        command:
        - sh
        - -c
        - |
          KSERVE_NS="{{ .Values.kserve.namespace }}"
          KSERVE_PORT="{{ .Values.kserve.predictorPort | default 8080 }}"

          echo "Checking KServe model availability in namespace: $KSERVE_NS"
          {{- range .Values.kserve.models }}
          # Check model: {{ .name }} with KServe model name: {{ .modelName }}
          SERVICE_NAME="{{ .name }}"
          MODEL_NAME="{{ .modelName }}"
          HEALTH_PATH="/v1/models/$MODEL_NAME"
          MAX_RETRIES=30
          RETRY=0
          until curl -f --connect-timeout 5 --max-time 10 http://$SERVICE_NAME.$KSERVE_NS.svc:$KSERVE_PORT$HEALTH_PATH 2>&1; do
            RETRY=$((RETRY+1))
            if [ $RETRY -ge $MAX_RETRIES ]; then
              echo "ERROR: Model $SERVICE_NAME (KServe name: $MODEL_NAME) not ready after $MAX_RETRIES attempts"
              echo "Check: kubectl get inferenceservice -n $KSERVE_NS"
              exit 1
            fi
            echo "Waiting for $SERVICE_NAME to be ready... ($RETRY/$MAX_RETRIES)"
            sleep 10
          done
          echo "âœ“ Model $SERVICE_NAME (KServe name: $MODEL_NAME) is ready"
          {{- end }}
          echo "All KServe models are healthy"
{{- end }}
